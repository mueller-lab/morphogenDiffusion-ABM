<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>morphogenDiffusionABM API documentation</title>
<meta name="description" content="Agent-based modeling of morphogen diffusion in extracellular cavities and interstitial spaces â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>morphogenDiffusionABM</code></h1>
</header>
<section id="section-intro">
<p>Agent-based modeling of morphogen diffusion in extracellular cavities and interstitial spaces.</p>
<p>The morphogens are the agents. The class agent has following attributes - id, type, name, pos, track, bState, bdTime,
resTime, bdCount, isBound, diffCoef, dist, jump.
Another class called 'simulateABM' contains methods to initialize the agents, update the states at each simulation step,
and record the observations.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Agent-based modeling of morphogen diffusion in extracellular cavities and interstitial spaces.

The morphogens are the agents. The class agent has following attributes - id, type, name, pos, track, bState, bdTime,
resTime, bdCount, isBound, diffCoef, dist, jump.
Another class called &#39;simulateABM&#39; contains methods to initialize the agents, update the states at each simulation step,
and record the observations.
&#34;&#34;&#34;
import matplotlib
matplotlib.use(&#39;Agg&#39;)
import matplotlib.pyplot as plt
from matplotlib import cm
import matplotlib.image as img
import numpy as np
from random import randint
import time
import argparse
import os
from pathlib import Path
from datetime import datetime
import pandas as pd
from scipy.stats import gaussian_kde

class agent(object):
    &#34;&#34;&#34;Generates agents and stores their attributes.&#34;&#34;&#34;
    def __init__(self, id):
        &#34;&#34;&#34;

        Attributes:
            `id`, `type`, `name`, `pos`, `track`, `bState`, `bdTime`, \n
            `resTime`, `bdCount`, `isBound`, `diffCoef`, `dist`, `jump`
        &#34;&#34;&#34;
        super(agent, self).__init__()
        self.id = id
        self.type=&#34;protein&#34;


    # plt.close()
class simulateABM(object):
    &#34;&#34;&#34;Contains methods to run the simulations.

    Attributes:
        `steps`, `grid`, `agents`, `gS`, `dir`, `jumpArr`, `boundDiff`, `boundDist`, `recepDens`, \n
        `receptorPos`, `membranePos`, `allowedPos`, ...
    &#34;&#34;&#34;

    def __init__(self, steps, gsize, dir, boundDiff = 0.5, recepDens= 200):
        super(simulateABM, self).__init__()
        self.steps = steps
        self.grid=np.ones((gsize[0],gsize[1]))
        self.agents= []
        self.gS=gsize
        self.dir = dir
        self.jumpArr =np.arange(0., 200.0, 0.01)
        self.boundDiff =  boundDiff# in px^2/s - diff coef for bound molecules
        self.boundDist = self.customPDF(self.jumpArr, self.boundDiff)
        self.recepDens= recepDens

    def drawCircle(self,pos,r):
        &#34;&#34;&#34;Returns radial positions at a given distance from the given position

        Args:
            `self` \n
            `pos`- [x,y] for given position \n
            `r` - radius of the circle \n

        Returns:
            A list of positions on the circle. \n
        &#34;&#34;&#34;
        r= r+1
        vPosList=[]
        nodes=16*r
        p0,p1=pos
        for i in range(int(nodes)):
            i=float(i)
            a =p0+r*np.cos(2.*(i+1)*np.pi/nodes)
            b =p1+r*np.sin(2.*(i+1)*np.pi/nodes)
            a= int(round(a))
            b= int(round(b))
            vPosList.append([a,b])
        return vPosList

    def getNeighbours(self, pos, r, any=0):
        &#34;&#34;&#34;Updates the self.neighbours with neighbours of given position.

        Args:
            `self` \n
            `pos` - given position [x,y] \n
            `r` - distance from pos \n
            `any` - boolean \n
                0- only take positions at distance r
                1- take all positions within radius r

        Modifies:
            Attributes:
                `neighbours` \n
        &#34;&#34;&#34;
        self.neighbours = np.zeros(8*r)
        if any:
            vPos = []
            for r1 in range(2, r):
                vPos.append(self.drawCircle(pos,r1))
            vPosList= [b for a in vPos for b in a]
        else:
            vPosList=self.drawCircle(pos,r)
        # vPosList = [[a[0]%self.gS[0],a[1]%self.gS[1]] for a in vPosList] # for per boundary
        self.neighbours = np.array([a for a in vPosList if 0&lt;a[0]&lt;gS[0] and 0&lt;a[1]&lt;gS[1]])

    def grid2D(self, gsize, gridImg=None, nrw=0):
        &#34;&#34;&#34;Makes the 2D grid for simulation

        Args:
            `self` \n
            `gsize`- size of the grid \n
            `gridImg` - input custom grid array (a numpy.array object) \n
            `nrw` - Narrowness (An integer to make the grid narrower or wider. \n
                nrw=0 means no change in initial grid \n
                nrw&gt;0 means make the grid narrower, nrw&lt;0 means make the grid wider \n
                1 nrw unit chages the width of extracellular space by 2 pixels or 20 nm.) \n

        Modifies:
            Class `simulateABM` \n
            Attributes:
                `grid`, `membranePos`, `allowedPos` \n
        &#34;&#34;&#34;
        if gridImg is not None:
            self.grid= gridImg
            self.gS = gsize
        else:
            grid=np.zeros((gsize[0],gsize[1]))
            x1,x2=(int(0.45*gsize[0]), int(0.55*gsize[0]))
            y1,y2=(int(0.6*gsize[1]), int(0.8*gsize[1]))
            for x in range(x1,x2):
                grid[x,:]=1
            for y in range(y1, y2):
                addCent = (y/gsize[1] - 0.6)
                x1,x2= (int((0.45-addCent)*gsize[0]), int((0.55+addCent)*gsize[0]))
                grid[x1:x2, y] = 1
            for y in range(y2, int(0.9*gsize[1])):
                grid[:,y]=1
            self.grid = grid

        nrwGrid = 1
        if nrw&lt;0:
            nrw= -nrw
            nrwGrid= 0

        for n in range(nrw):
            self.getMemPos()
            for a in self.membranePos:
                self.grid[a[0],a[1]] = 0 if nrwGrid else 1
                self.getNeighbours(a,1)
                for b in self.neighbours:
                    self.grid[b[0],b[1]] = 0 if nrwGrid else 1

        self.allowedPos = np.argwhere(self.grid)
        maxX = np.max(self.allowedPos[:,0])
        self.oneSidePos=np.array([a for a in self.allowedPos if a[0]==maxX])
        print(f&#34;len of allowedPos is {len(self.allowedPos)}&#34;)

        #save grid as .csv and .tiff files
        plt.figure()
        plt.imshow(self.grid.T, origin= &#34;lower&#34;)
        plt.savefig(self.dir/&#34;grid.tif&#34;)
        plt.close()
        np.savetxt(self.dir/&#34;grid.csv&#34;, self.grid, delimiter= &#34;,&#34;, fmt=&#39;%s&#39;)

    def getMemPos(self, dir=None):
        &#34;&#34;&#34;Detects edges (membrane positions) in the grid.

        Args:
            `self` \n
            `dir` - default = None, provide a directory path to save a .tif image of the membrane positions \n

        Modifies:
            Attribute:
                `membranePos` \n
        &#34;&#34;&#34;
        imGradx,imGrady = np.gradient(self.grid)
        imGrad = np.absolute(imGradx)+np.absolute(imGrady)
        self.membranePos=np.argwhere(imGrad)
        if dir is not None:
            self.membranePos_sort=self.membranePos[np.argsort(self.membranePos[:,1])]
            self.memSet = set([tuple(x) for x in self.membranePos_sort])
            showMem = np.zeros((self.gS[0], self.gS[1]))
            for [x,y] in self.membranePos_sort: showMem[x,y] = 100
            plt.figure()
            plt.imshow(showMem.T, origin= &#34;lower&#34;)
            plt.savefig(self.dir/&#34;membrane.tif&#34;)
        print(f&#34;len of membranePos is {len(self.membranePos)}&#34;)

    # define a probability distribution function
    def customPDF(self,r, D=10, tau=0.01):
        &#34;&#34;&#34;Generates distribution of probabilities for given jump distances

        Args:
            `self` \n
            `r` - array of jump distance (numpy.array) \n
            `D` - diffusion coefficient (in um^2/s) \n
            `tau` - duration of the simulation step (in s). default = 0.01 (10 ms) \n

        Returns:
            Array of probabilities of jump distances \n
        &#34;&#34;&#34;
        # D = 10 mu^2/s, tau = 0.01 s
        # r is jump distance in pixels
        D = D*10**4 # conversion of um^2 to px^2/s
        p= (r/(2*D*tau)) * np.exp(-r**2/(4*D*tau))
        p = p/np.sum(p)
        return p

    def initialize(self, num=1, name=&#34;sailor&#34;, diffCoef=10, bindSth=0, oneSide=0, resTime=0, eqFrac=0.5 ):
        &#34;&#34;&#34;Initializes the agents for the simulation

        Args:
            `num` - number of agents \n
            `name` - name of agent \n
            `diffCoef` - diffusion coefficient \n
            `bindSth` - bindSth (integer - 0, 1, ...). A receptor with the radius of bindSth is detected for binding. \n
            `oneSide` - boolean (default = 0), \n
                0 to initiate agents at random positions, \n
                1 to initiate agents on one side of the grid \n
            `resTime` - average residence time for the agent \n
            `eqFrac` - initial bound fraction (0 means all agents are free, 1 means all agents are bound, default = 0.5) \n

        Modifies:
            Class `agent` \n
            Attributes:
                `name`, `id`, `track`, `bState`, `pos`, `resTime`, `bdTime`, `bdCount`, `isBound`, `diffCoef`, `dist`, `jump`, ... \n
            Class `simulateABM` \n
            Attributes:
                `receptorPos`, `agents` \n
        &#34;&#34;&#34;
        # define the allowed receptor positions along the membrane
        # The idea is at the membrane within one step one can find a zero as well as nonzero position
        self.receptorPos=[]
        for i in range(num):
            ag=agent(i)
            ag.track=np.zeros((self.steps+1, 2))
            # ag.id=i
            ag.name= f&#34;{name}_{i:04d}&#34;
            ag.bState= []
            if &#34;oep&#34; in ag.name:
                # ag.pos= self.membranePos[randint(0,len(self.membranePos)-1)] # to randomly pick initial position
                ag.pos= self.membranePos_sort[i*self.recepDens] # uniform receptor positions
                self.receptorPos.append(ag.pos)
            else:
                ag.resTime=resTime
                ag.bdTime= int(100*ag.resTime*np.log(1/np.random.uniform(0.001,0.999,1))) # exponential distribution for binding times
                ag.bdCount=0
                ag.isBound=np.random.choice([0,1], p=[1-eqFrac, eqFrac])
                ag.diffCoef=diffCoef
                ag.dist = self.customPDF(self.jumpArr, ag.diffCoef)
                ag.jump= int(np.random.choice(self.jumpArr, size=1 , p=ag.dist))
                if oneSide==1:
                    ag.pos= self.oneSidePos[randint(0,len(self.oneSidePos)-1)]
                else:
                    ag.pos= self.allowedPos[randint(0,len(self.allowedPos)-1)]
            ag.track[0]=ag.pos
            ag.bindSth=bindSth
            self.agents.append(ag)
        self.receptorPos=np.asarray(self.receptorPos)

    def update(self,step):
        &#34;&#34;&#34;To update the agents at each simulation step

        Args:
            `self` \n
            `step` - simulation step number (int) \n

        Modifies:
            Class `agent` \n
            Attributes:
                `bState`, `pos`, `isBound`, `bdCount`, `jump` \n
            Class `simulateABM` \n
            Attributes:
                `agents`, `neighbours` \n
        &#34;&#34;&#34;
        for ag in self.agents:
            x = ag.pos
            # moveTo = []
            if &#34;oep&#34; in ag.name: # update for the receptor
                ag.bState.append(0) # this is not really meaningful,
            else: # this is for the ligands
                # proximity = [m for m in self.receptorPos if sum((m-x)**2) &lt;= 2*(ag.bindSth)**2]
                if ag.isBound: # bound ligand stays bound if counter on resTime hasn&#39;t run out
                    if ag.bdCount&lt;=ag.bdTime:
                        ag.bState.append(1)
                        ag.jump= int(np.random.choice(self.jumpArr, size=1 , p=self.boundDist))
                        self.getNeighbours(x,ag.jump)
                        self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                        # ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                        if len(self.neighbours)&gt;1:
                            ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                            # print(f&#34;step {step} agent {ag.name} chose random move &#34;)
                        elif ag.jump&gt;2:
                            print(f&#34;Using all positions within the jump radius {ag.jump}&#34;)
                            self.getNeighbours(x,ag.jump, any=1)
                            self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                            if len(self.neighbours)&gt;1:
                                ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                            else:
                                print(f&#34;agent {ag.name} can&#39;t move&#34;)
                        else:
                            None
                        ag.bdCount+=1
                    else: # when the counter is exceeded ligand becomes unbound
                        ag.isBound=0
                        ag.bState.append(0)
                        ag.bdCount=0
                        ag.jump= int(np.random.choice(self.jumpArr, size=1 , p=ag.dist))
                        self.getNeighbours(x,ag.jump)
                        self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                        if len(self.neighbours)&gt;1:
                            ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                            # print(f&#34;step {step} agent {ag.name} chose random move &#34;)
                        elif ag.jump&gt;2:
                            print(f&#34;Using all positions within the jump radius {ag.jump}&#34;)
                            self.getNeighbours(x,ag.jump, any=1)
                            self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                            if len(self.neighbours)&gt;1:
                                ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                            else:
                                print(f&#34;agent {ag.name} can&#39;t move&#34;)
                        else:
                            None
                elif len([m for m in self.receptorPos if sum((m-x)**2) &lt;= ag.bindSth**2])&gt;0: # for an unbound ligand, check if a receptor is nearby
                    ag.isBound=1
                    ag.bdTime= int(100*ag.resTime*np.log(1/np.random.uniform(0.001,0.999,1))) # exponential distribution for binding times
                    ag.bState.append(1)
                    ag.jump= int(np.random.choice(self.jumpArr, size=1 , p=self.boundDist))
                    self.getNeighbours(x,ag.jump)
                    self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                    # ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                    if len(self.neighbours)&gt;1:
                        ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                        # print(f&#34;step {step} agent {ag.name} chose random move &#34;)
                    elif ag.jump&gt;2:
                        print(f&#34;Using all positions within the jump radius {ag.jump}&#34;)
                        self.getNeighbours(x,ag.jump, any=1)
                        self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                        if len(self.neighbours)&gt;1:
                            ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                        else:
                            print(f&#34;agent {ag.name} can&#39;t move&#34;)
                    else:
                        None
                    ag.bdCount+=1
                else:
                    ag.bState.append(0)
                    ag.jump= int(np.random.choice(self.jumpArr, size=1 , p=ag.dist))
                    self.getNeighbours(x,ag.jump)
                    self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                    if len(self.neighbours)&gt;1:
                        ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                        # print(f&#34;step {step} agent {ag.name} chose random move &#34;)
                    elif ag.jump&gt;2:
                        print(f&#34;Using all positions within the jump radius {ag.jump}&#34;)
                        self.getNeighbours(x,ag.jump, any=1)
                        self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                        if len(self.neighbours)&gt;1:
                            ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                        else:
                            print(f&#34;agent {ag.name} can&#39;t move&#34;)
                    else:
                        None
            ag.track[step+1]=ag.pos

    def observe(self,step,fig,cmap):
        &#34;&#34;&#34;Generates plots of agent tracks

        Args:
            `self`\n
            `step`- simulation step number \n
            `fig` - plt.figure (blank figure to draw the plot)\n
            `cmap` - colormap to color different agents \n

        Generates:
            a plot of tracks at self.dir \n
        &#34;&#34;&#34;
        plt.title(f&#34;time_{step*10}_ms&#34;)
        plt.xlim(0,self.gS[0])
        plt.ylim(0,self.gS[1])
        for ag, col in zip(self.agents, cmap):
            x = ag.track[:step+2,0][-2:]
            y = ag.track[:step+2,1][-2:]
            if &#34;oep&#34; in ag.name:
                plt.plot(x[-1], y[-1], &#39;ks&#39;, markersize=0.5)
            else:
                plt.plot(x,y, &#39;-&#39;, label=ag.name, linewidth=2, color = col, zorder=2)
                # x,y=ag.track[-2]
                # x1,y1=ag.track[-1]
                # dx,dy=[x1-x,y1-y]
                # plt.arrow(x,y,dx/2,dy/2,lw=0, color=&#39;k&#39;, head_width=40., zorder=20)
                dx,dy=[x[1]-x[0],y[1]-y[0]]
                plt.arrow(x[0],y[0],dx/2,dy/2, lw=0., fc=&#34;k&#34;, ec=&#34;k&#34;, head_width=10, head_length=10, zorder=20)
        # plt.legend(loc=&#39;lower left&#39;)
        fig.canvas.draw_idle()
        fname=self.dir/f&#34;traceAt_{step}.tif&#34;
        plt.savefig(fname)
        fig.canvas.flush_events()
        plt.clf()

    def plotBoundFrac(self, step, fig):
        &#34;&#34;&#34;To plot the bound fraction.&#34;&#34;&#34;
        plt.title(f&#34;Time {step*0.01:.3f} s&#34;)
        plt.ylim(0,1)
        nodFrac=[ag.isBound for ag in self.agents if &#34;nod&#34; in ag.name]
        lefFrac=[ag.isBound for ag in self.agents if &#34;lef&#34; in ag.name]
        x= [&#34;nodal&#34;, &#34;lefty&#34;]
        y=[sum(nodFrac)/len(nodFrac), sum(lefFrac)/len(lefFrac)]
        plt.ylabel(&#34;Bound Fraction&#34;)
        plt.bar(x,y, width=0.2)
        fig.canvas.draw_idle()
        fname=self.dir/f&#34;BoundFrac_{step}.tif&#34;
        plt.savefig(fname)
        fig.canvas.flush_events()
        plt.clf()


if __name__==&#34;__main__&#34;:
    print(&#34;\n**************************************************** \nStarting the simulation program...&#34;)
    t1 = time.time()

    cwdPath=Path(os.path.abspath(os.getcwd()))
    now=datetime.now()
    datetime_str=(now.strftime(&#34;%Y%m%d_%H%M%S_&#34;))

    # get user arguments
    parser = argparse.ArgumentParser(description=&#34;Available user options.&#34;)
    parser.add_argument(&#34;-n&#34;, &#34;--num&#34;, type=int, nargs=&#34;+&#34;, default=1, help=&#34;Number of agents. default=1&#34;)
    parser.add_argument(&#34;-gS&#34;, &#34;--gridSize&#34;, type=int, nargs=&#34;+&#34;, default=[100,100], help=&#34;Size of the 2D grid. default=[100,100]&#34;)
    parser.add_argument(&#34;-st&#34;, &#34;--steps&#34;, type=int, default=500, help=&#34;Number of simulation steps. default=500&#34;)
    parser.add_argument(&#34;-nrw&#34;, &#34;--narrowInterface&#34;, type=int, default=8, help=&#34;Steps to reduce interface width. default=5&#34;)
    parser.add_argument(&#34;-slr&#34;, &#34;--sailor&#34;, type=int, nargs=&#34;+&#34;, default=0, help=&#34;Types of sailor (list). default=0&#34;)
    parser.add_argument(&#34;-lv&#34;, &#34;--live&#34;, type=str, default=&#34;No&#34;, help=&#34;Whether to show plots during runtime or not. default=No&#34;)
    parser.add_argument(&#34;-uImg&#34;, &#34;--useImg&#34;, type=str, default=&#34;No&#34;, help=&#34;Whether to use given image to make the grid. default=No&#34;)
    parser.add_argument(&#34;-iName&#34;, &#34;--imgName&#34;, type=str, default=&#34;s8192_4_scaled&#34;, help=&#34;Name of the image file. default=s8192_4_scaled.tiff&#34;)
    parser.add_argument(&#34;-parScr&#34;, &#34;--parameterScreen&#34;, type=str, default=&#34;No&#34;, help=&#34;Whether to perform a parameter screen. default=No&#34;)
    parser.add_argument(&#34;-parID&#34;, &#34;--parameterID&#34;, type=int, default=0, help=&#34;Row number in the parameter file. default=0&#34;)
    options = parser.parse_args()

    n, gS, st, nrw, slr, live, useImg, iName, parScr, parID= (options.num, options.gridSize, options.steps, options.narrowInterface, \
    options.sailor, options.live, options.useImg, options.imgName, options.parameterScreen, options.parameterID)

    recepDens= 200 # default receptor density
    nodBSt=2 # nodal binding threshold
    lefBSt=2 # lefty binding threshold
    nodRT=16 # nodal residence time
    lefRT= 1 # lefty residence time
    freeDiff = 30 # free diffusion coefficient
    boundDiff = 0.5 # bound diffusion coefficient

    if parScr==&#34;Yes&#34;:
        parFile= np.genfromtxt(cwdPath/&#39;parFile_20220301.csv&#39;, delimiter= &#39;,&#39;, skip_header=1, dtype=&#39;int&#39;)
        parAr = parFile[parID,:]
        BS, nrw, recepDens, rTm = parAr
        nodBSt=BS
        lefBSt=BS
        eqF = rTm*BS*2/(100*np.log10(recepDens))
        print(f&#34;nodBSt={nodBSt}, nodRT={nodRT}, lefBSt={lefBSt}, lefRT={lefRT}, nrw={nrw}, recepDens={recepDens}&#34;)
    else:
        BS, rTm, eqF = (0, 0, 0)



    #create result directory
    dirName=str(datetime_str+ f&#34;mth1_{st}steps_grid_{iName}_ID{parID:03d}&#34;)
    # dirName=str(datetime_str+ f&#34;mth1_{st}steps_grid_{iName}_ID{parID:03d}&#34;)
    # dirName=str(datetime_str+ f&#34;unf_oep{st}steps_grid_circle_cells&#34;)
    resultPath=cwdPath/&#39;data&#39;/dirName
    resultPath.mkdir(mode=0o777, parents=True, exist_ok=True)
    print(f&#34;Created result directory {dirName} at {time.time() - t1} sec ...&#34;)

    #get grid image
    # imageName = &#34;s8192_3_scaled.tiff&#34;
    imageName = f&#34;{iName}.tiff&#34;
    # imageName = &#34;s4096_4_scaled.tiff&#34;
    # imageName = &#34;grid_circle_cells.tif&#34;
    image = np.array(img.imread(cwdPath/&#34;newGrids&#34;/imageName))
    image = np.where(image ==0, 1, 0)
    image = image[::-1]
    image = np.transpose(image)


    # run simulations using class simulateABM
    sim = simulateABM(st, gS, resultPath, boundDiff = boundDiff, recepDens=recepDens)
    if useImg==&#34;Yes&#34;:
        gS=image.shape[:2]
        sim.grid2D(gS, image, nrw)
    else:
        sim.grid2D(gS, nrw=0)
    print(f&#34;Created a {gS[0]} by {gS[1]} grid at {time.time() - t1} sec ...&#34;)

    sim.getMemPos(resultPath) # detect membrane edges using np.gradient
    n[0]=int(len(sim.membranePos)/recepDens)
    print(f&#34;n[0] is {n[0]}&#34;)


    # Initialization of the agents at their starting position
    if 1 in slr:
        sim.initialize(n[1], diffCoef=freeDiff, name = &#34;nodal&#34;, bindSth=nodBSt, oneSide=0, resTime=nodRT, eqFrac= 0.5)
        print(f&#34;Initialized nodal at {time.time() - t1} sec ...&#34;)
    if 2 in slr:
        sim.initialize(n[2], diffCoef=freeDiff, name = &#34;lefty&#34;, bindSth =lefBSt, oneSide=0, resTime =lefRT, eqFrac= 0.1)
        print(f&#34;Initialized lefty at {time.time() - t1} sec ...&#34;)
    if 3 in slr:
        sim.initialize(n[3], diffCoef=freeDiff, name = &#34;secHalo&#34;, bindSth =0, oneSide=0, resTime =0, eqFrac= 0)
        print(f&#34;Initialized secHalo at {time.time() - t1} sec ...&#34;)
    if 4 in slr:
        sim.initialize(n[4], diffCoef=freeDiff, name = &#34;morphogen&#34;, bindSth =BS, oneSide=0, resTime =rTm, eqFrac=eqF)
        print(f&#34;Initialized morphogen at {time.time() - t1} sec ...&#34;)
    if 0 in slr:
        sim.initialize(n[0], name = &#34;oep&#34;)
        print(f&#34;Initialized oep at {time.time() - t1} sec ...&#34;)

    print(&#34;Initialization completed ...&#34;)

    # save simulation parametes to a text file
    par_file_path = resultPath/&#39;param.txt&#39;
    fo = open(par_file_path, &#34;w&#34;)
    fo.write(f&#34;oep jump=0, num={n[0]}, density={recepDens} \nnodal, num={n[1]}, binding={nodBSt}, diffCoef={freeDiff}, resTime={nodRT} \
    \nlefty, num={n[2]}, binding={lefBSt}, diffCoef={freeDiff}, resTime={lefRT} \nbound, diffCoef={boundDiff} \nnrw = {nrw} \
    \nsecHalo, num={n[3]}, binding= 0, diffCoef={freeDiff}, resTime=0, eqFrac= 0 \
    \nmorphogen, num={n[4]}, binding= {BS}, diffCoef={freeDiff}, resTime={rTm}, eqFrac= {eqF}&#34;)
    fo.close()

    # simulate the system using timesteps of 10 ms. upto 2000 steps are simulated (20 s)
    # the jump distances for morphogens are picked from a random.normal distribution.
    # average jump-distance = r = 2*sqrt(D*t), for D= 9 um^2/s --&gt; r = 600 nm, D=16 --&gt; r = 800 nm
    # the mean and variance of the normal distribution can be set using known diffusivities of nodals and leftys
    # binding to a receptor (oep) will reduce the jump-distance. Use a different normal distribution.
    # binding strength is modulated by setting different proximity threshold for binding.
    # binding duration is


    fig=plt.figure(figsize=[0.001*gS[0], 0.001*gS[1]])
    # fig1=plt.figure()
    viridis = cm.get_cmap(&#39;viridis&#39;, 256)
    nonOepLen = len([1 for ag in sim.agents if &#34;oep&#34; not in ag.name])
    cmap = viridis(np.linspace(0, 1, nonOepLen))
    if 0 in slr:
        extraCmap = np.array([[1.,1.,1.,1.] for i in range(len(sim.agents)-nonOepLen)])
        cmap = np.concatenate((cmap, extraCmap), axis=0)

    # plotBnd=&#34;Yes&#34;
    plotBnd=&#34;No&#34;
    for step in range(st):
        # print(f&#34;Running step {step} at {time.time() - t1} sec ... &#34;)
        if step%200 ==0: print(f&#34;Running step {step}&#34;)
        sim.update(step) # update position at each step
        if live==&#34;Yes&#34; :
            plt.ion()
            plt.show()
            sim.observe(step,fig,cmap)
        elif live==&#34;Back&#34;: # and step%5==0:
            sim.observe(step,fig,cmap)
        else:
            None
        if plotBnd==&#34;Yes&#34; and step%5==0:
            # plt.ion()
            # plt.show()
            sim.plotBoundFrac(step, fig1)
    plt.close()


    #make a figure of localization densities
    def plotLocalization(agName=&#34;nodal&#34;):
        plt.figure(figsize=[0.0012*gS[0], 0.001*gS[1]])
        plt.xlim(0,gS[0])
        plt.ylim(0,gS[1])

        allTracks=[]
        for ag in sim.agents:
            if &#34;oep&#34; in ag.name:
                plt.plot(ag.track[-1][0], ag.track[-1][1],&#39;ks&#39;, markersize=0.5)
            if agName in ag.name:
                for a in ag.track:
                    allTracks.append(a)
        allTracks=np.array(allTracks)

        # Calculate the point density
        unique, z = np.unique(allTracks, axis=0, return_counts=True)

        # Sort the points by density, so that the densest points are plotted last
        idx = z.argsort()
        xy = unique[idx]
        z= z[idx]
        sc = plt.scatter(xy[:,0],xy[:,1], c=z, s=1, cmap=&#39;viridis&#39;)
        plt.colorbar(sc)
        # plt.legend(loc=&#39;lower left&#39;)
        fName = &#34;locDensity_%s.tif&#34;%(agName)
        fname=resultPath/fName
        plt.savefig(fname)
        plt.close()


    print(&#34;Saving tracks and bound-state csv files ...&#34;)
    # save tracks to a .csv file
    tracksArray = np.zeros((2*len(sim.agents), st+1))

    for ag, i in zip(sim.agents, range(2*len(sim.agents))):
        tracksArray[2*i,:]= [m[0] for m in ag.track]
        tracksArray[2*i+1,:] = [m[1] for m in ag.track]

    rowNames = [f&#34;{ag.name}_{i}&#34; for ag in sim.agents for i in [&#34;x&#34;, &#34;y&#34;]]

    tracksDf = pd.DataFrame(tracksArray, index=rowNames)
    fName= resultPath/&#34;tracks.csv&#34;
    tracksDf.to_csv(fName, header=True, index=True)

    # save array of bound states for each agent
    boundArray = np.zeros((len(sim.agents), st))

    # get binding times
    for ag, i in zip(sim.agents, range(len(sim.agents))):
        boundArray[i,:]= [m for m in ag.bState]
        # analysis to get residence times and binding frequencies
        # idea - split the ag.bState list into lists of continuous ones and zeros
        # then count zero lists and ones lists and get their lengths- estimate bound and unbound interval times
        boundIntv = []
        counter = 0
        for j in range(len(ag.bState)):
            if ag.bState[j]==1:
                counter+=1
            else:
                if counter&gt;0: boundIntv.append(counter*0.010)
                counter=0
        if ag.bState[-1]==1:
            boundIntv.append(counter*0.010)
        if len(boundIntv)&gt;0:
            print(f&#34;For {ag.name} the tot_ResTime = {sum(boundIntv)} s&#34;)

    rowNames = [f&#34;{ag.name}&#34; for ag in sim.agents]

    bindingDf = pd.DataFrame(boundArray, index=rowNames)
    fName= resultPath/&#34;binding.csv&#34;
    bindingDf.to_csv(fName, header=True, index=True)

    if 1 in slr:
        plotLocalization(&#34;nodal&#34;)
    if 2 in slr:
        plotLocalization(&#34;lefty&#34;)
    if 3 in slr:
        plotLocalization(&#34;secHalo&#34;)
    if 4 in slr:
        plotLocalization(&#34;morphogen&#34;)


    t2= time.time()
    totalSec= t2-t1
    Sec=int(totalSec%60)
    Hrs=int(totalSec//3600)
    Min=int((totalSec%3600)//60)

    print (&#34;Program completed in %sHr:%sMin:%ssec\n&#34;%(Hrs,Min,Sec))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="morphogenDiffusionABM.agent"><code class="flex name class">
<span>class <span class="ident">agent</span></span>
<span>(</span><span>id)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates agents and stores their attributes.</p>
<h2 id="attributes">Attributes</h2>
<p><code>id</code>, <code>type</code>, <code>name</code>, <code>pos</code>, <code>track</code>, <code>bState</code>, <code>bdTime</code>, </p>
<p><code>resTime</code>, <code>bdCount</code>, <code>isBound</code>, <code>diffCoef</code>, <code>dist</code>, <code>jump</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class agent(object):
    &#34;&#34;&#34;Generates agents and stores their attributes.&#34;&#34;&#34;
    def __init__(self, id):
        &#34;&#34;&#34;

        Attributes:
            `id`, `type`, `name`, `pos`, `track`, `bState`, `bdTime`, \n
            `resTime`, `bdCount`, `isBound`, `diffCoef`, `dist`, `jump`
        &#34;&#34;&#34;
        super(agent, self).__init__()
        self.id = id
        self.type=&#34;protein&#34;</code></pre>
</details>
</dd>
<dt id="morphogenDiffusionABM.simulateABM"><code class="flex name class">
<span>class <span class="ident">simulateABM</span></span>
<span>(</span><span>steps, gsize, dir, boundDiff=0.5, recepDens=200)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains methods to run the simulations.</p>
<h2 id="attributes">Attributes</h2>
<p><code>steps</code>, <code>grid</code>, <code>agents</code>, <code>gS</code>, <code>dir</code>, <code>jumpArr</code>, <code>boundDiff</code>, <code>boundDist</code>, <code>recepDens</code>, </p>
<p><code>receptorPos</code>, <code>membranePos</code>, <code>allowedPos</code>, &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class simulateABM(object):
    &#34;&#34;&#34;Contains methods to run the simulations.

    Attributes:
        `steps`, `grid`, `agents`, `gS`, `dir`, `jumpArr`, `boundDiff`, `boundDist`, `recepDens`, \n
        `receptorPos`, `membranePos`, `allowedPos`, ...
    &#34;&#34;&#34;

    def __init__(self, steps, gsize, dir, boundDiff = 0.5, recepDens= 200):
        super(simulateABM, self).__init__()
        self.steps = steps
        self.grid=np.ones((gsize[0],gsize[1]))
        self.agents= []
        self.gS=gsize
        self.dir = dir
        self.jumpArr =np.arange(0., 200.0, 0.01)
        self.boundDiff =  boundDiff# in px^2/s - diff coef for bound molecules
        self.boundDist = self.customPDF(self.jumpArr, self.boundDiff)
        self.recepDens= recepDens

    def drawCircle(self,pos,r):
        &#34;&#34;&#34;Returns radial positions at a given distance from the given position

        Args:
            `self` \n
            `pos`- [x,y] for given position \n
            `r` - radius of the circle \n

        Returns:
            A list of positions on the circle. \n
        &#34;&#34;&#34;
        r= r+1
        vPosList=[]
        nodes=16*r
        p0,p1=pos
        for i in range(int(nodes)):
            i=float(i)
            a =p0+r*np.cos(2.*(i+1)*np.pi/nodes)
            b =p1+r*np.sin(2.*(i+1)*np.pi/nodes)
            a= int(round(a))
            b= int(round(b))
            vPosList.append([a,b])
        return vPosList

    def getNeighbours(self, pos, r, any=0):
        &#34;&#34;&#34;Updates the self.neighbours with neighbours of given position.

        Args:
            `self` \n
            `pos` - given position [x,y] \n
            `r` - distance from pos \n
            `any` - boolean \n
                0- only take positions at distance r
                1- take all positions within radius r

        Modifies:
            Attributes:
                `neighbours` \n
        &#34;&#34;&#34;
        self.neighbours = np.zeros(8*r)
        if any:
            vPos = []
            for r1 in range(2, r):
                vPos.append(self.drawCircle(pos,r1))
            vPosList= [b for a in vPos for b in a]
        else:
            vPosList=self.drawCircle(pos,r)
        # vPosList = [[a[0]%self.gS[0],a[1]%self.gS[1]] for a in vPosList] # for per boundary
        self.neighbours = np.array([a for a in vPosList if 0&lt;a[0]&lt;gS[0] and 0&lt;a[1]&lt;gS[1]])

    def grid2D(self, gsize, gridImg=None, nrw=0):
        &#34;&#34;&#34;Makes the 2D grid for simulation

        Args:
            `self` \n
            `gsize`- size of the grid \n
            `gridImg` - input custom grid array (a numpy.array object) \n
            `nrw` - Narrowness (An integer to make the grid narrower or wider. \n
                nrw=0 means no change in initial grid \n
                nrw&gt;0 means make the grid narrower, nrw&lt;0 means make the grid wider \n
                1 nrw unit chages the width of extracellular space by 2 pixels or 20 nm.) \n

        Modifies:
            Class `simulateABM` \n
            Attributes:
                `grid`, `membranePos`, `allowedPos` \n
        &#34;&#34;&#34;
        if gridImg is not None:
            self.grid= gridImg
            self.gS = gsize
        else:
            grid=np.zeros((gsize[0],gsize[1]))
            x1,x2=(int(0.45*gsize[0]), int(0.55*gsize[0]))
            y1,y2=(int(0.6*gsize[1]), int(0.8*gsize[1]))
            for x in range(x1,x2):
                grid[x,:]=1
            for y in range(y1, y2):
                addCent = (y/gsize[1] - 0.6)
                x1,x2= (int((0.45-addCent)*gsize[0]), int((0.55+addCent)*gsize[0]))
                grid[x1:x2, y] = 1
            for y in range(y2, int(0.9*gsize[1])):
                grid[:,y]=1
            self.grid = grid

        nrwGrid = 1
        if nrw&lt;0:
            nrw= -nrw
            nrwGrid= 0

        for n in range(nrw):
            self.getMemPos()
            for a in self.membranePos:
                self.grid[a[0],a[1]] = 0 if nrwGrid else 1
                self.getNeighbours(a,1)
                for b in self.neighbours:
                    self.grid[b[0],b[1]] = 0 if nrwGrid else 1

        self.allowedPos = np.argwhere(self.grid)
        maxX = np.max(self.allowedPos[:,0])
        self.oneSidePos=np.array([a for a in self.allowedPos if a[0]==maxX])
        print(f&#34;len of allowedPos is {len(self.allowedPos)}&#34;)

        #save grid as .csv and .tiff files
        plt.figure()
        plt.imshow(self.grid.T, origin= &#34;lower&#34;)
        plt.savefig(self.dir/&#34;grid.tif&#34;)
        plt.close()
        np.savetxt(self.dir/&#34;grid.csv&#34;, self.grid, delimiter= &#34;,&#34;, fmt=&#39;%s&#39;)

    def getMemPos(self, dir=None):
        &#34;&#34;&#34;Detects edges (membrane positions) in the grid.

        Args:
            `self` \n
            `dir` - default = None, provide a directory path to save a .tif image of the membrane positions \n

        Modifies:
            Attribute:
                `membranePos` \n
        &#34;&#34;&#34;
        imGradx,imGrady = np.gradient(self.grid)
        imGrad = np.absolute(imGradx)+np.absolute(imGrady)
        self.membranePos=np.argwhere(imGrad)
        if dir is not None:
            self.membranePos_sort=self.membranePos[np.argsort(self.membranePos[:,1])]
            self.memSet = set([tuple(x) for x in self.membranePos_sort])
            showMem = np.zeros((self.gS[0], self.gS[1]))
            for [x,y] in self.membranePos_sort: showMem[x,y] = 100
            plt.figure()
            plt.imshow(showMem.T, origin= &#34;lower&#34;)
            plt.savefig(self.dir/&#34;membrane.tif&#34;)
        print(f&#34;len of membranePos is {len(self.membranePos)}&#34;)

    # define a probability distribution function
    def customPDF(self,r, D=10, tau=0.01):
        &#34;&#34;&#34;Generates distribution of probabilities for given jump distances

        Args:
            `self` \n
            `r` - array of jump distance (numpy.array) \n
            `D` - diffusion coefficient (in um^2/s) \n
            `tau` - duration of the simulation step (in s). default = 0.01 (10 ms) \n

        Returns:
            Array of probabilities of jump distances \n
        &#34;&#34;&#34;
        # D = 10 mu^2/s, tau = 0.01 s
        # r is jump distance in pixels
        D = D*10**4 # conversion of um^2 to px^2/s
        p= (r/(2*D*tau)) * np.exp(-r**2/(4*D*tau))
        p = p/np.sum(p)
        return p

    def initialize(self, num=1, name=&#34;sailor&#34;, diffCoef=10, bindSth=0, oneSide=0, resTime=0, eqFrac=0.5 ):
        &#34;&#34;&#34;Initializes the agents for the simulation

        Args:
            `num` - number of agents \n
            `name` - name of agent \n
            `diffCoef` - diffusion coefficient \n
            `bindSth` - bindSth (integer - 0, 1, ...). A receptor with the radius of bindSth is detected for binding. \n
            `oneSide` - boolean (default = 0), \n
                0 to initiate agents at random positions, \n
                1 to initiate agents on one side of the grid \n
            `resTime` - average residence time for the agent \n
            `eqFrac` - initial bound fraction (0 means all agents are free, 1 means all agents are bound, default = 0.5) \n

        Modifies:
            Class `agent` \n
            Attributes:
                `name`, `id`, `track`, `bState`, `pos`, `resTime`, `bdTime`, `bdCount`, `isBound`, `diffCoef`, `dist`, `jump`, ... \n
            Class `simulateABM` \n
            Attributes:
                `receptorPos`, `agents` \n
        &#34;&#34;&#34;
        # define the allowed receptor positions along the membrane
        # The idea is at the membrane within one step one can find a zero as well as nonzero position
        self.receptorPos=[]
        for i in range(num):
            ag=agent(i)
            ag.track=np.zeros((self.steps+1, 2))
            # ag.id=i
            ag.name= f&#34;{name}_{i:04d}&#34;
            ag.bState= []
            if &#34;oep&#34; in ag.name:
                # ag.pos= self.membranePos[randint(0,len(self.membranePos)-1)] # to randomly pick initial position
                ag.pos= self.membranePos_sort[i*self.recepDens] # uniform receptor positions
                self.receptorPos.append(ag.pos)
            else:
                ag.resTime=resTime
                ag.bdTime= int(100*ag.resTime*np.log(1/np.random.uniform(0.001,0.999,1))) # exponential distribution for binding times
                ag.bdCount=0
                ag.isBound=np.random.choice([0,1], p=[1-eqFrac, eqFrac])
                ag.diffCoef=diffCoef
                ag.dist = self.customPDF(self.jumpArr, ag.diffCoef)
                ag.jump= int(np.random.choice(self.jumpArr, size=1 , p=ag.dist))
                if oneSide==1:
                    ag.pos= self.oneSidePos[randint(0,len(self.oneSidePos)-1)]
                else:
                    ag.pos= self.allowedPos[randint(0,len(self.allowedPos)-1)]
            ag.track[0]=ag.pos
            ag.bindSth=bindSth
            self.agents.append(ag)
        self.receptorPos=np.asarray(self.receptorPos)

    def update(self,step):
        &#34;&#34;&#34;To update the agents at each simulation step

        Args:
            `self` \n
            `step` - simulation step number (int) \n

        Modifies:
            Class `agent` \n
            Attributes:
                `bState`, `pos`, `isBound`, `bdCount`, `jump` \n
            Class `simulateABM` \n
            Attributes:
                `agents`, `neighbours` \n
        &#34;&#34;&#34;
        for ag in self.agents:
            x = ag.pos
            # moveTo = []
            if &#34;oep&#34; in ag.name: # update for the receptor
                ag.bState.append(0) # this is not really meaningful,
            else: # this is for the ligands
                # proximity = [m for m in self.receptorPos if sum((m-x)**2) &lt;= 2*(ag.bindSth)**2]
                if ag.isBound: # bound ligand stays bound if counter on resTime hasn&#39;t run out
                    if ag.bdCount&lt;=ag.bdTime:
                        ag.bState.append(1)
                        ag.jump= int(np.random.choice(self.jumpArr, size=1 , p=self.boundDist))
                        self.getNeighbours(x,ag.jump)
                        self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                        # ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                        if len(self.neighbours)&gt;1:
                            ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                            # print(f&#34;step {step} agent {ag.name} chose random move &#34;)
                        elif ag.jump&gt;2:
                            print(f&#34;Using all positions within the jump radius {ag.jump}&#34;)
                            self.getNeighbours(x,ag.jump, any=1)
                            self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                            if len(self.neighbours)&gt;1:
                                ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                            else:
                                print(f&#34;agent {ag.name} can&#39;t move&#34;)
                        else:
                            None
                        ag.bdCount+=1
                    else: # when the counter is exceeded ligand becomes unbound
                        ag.isBound=0
                        ag.bState.append(0)
                        ag.bdCount=0
                        ag.jump= int(np.random.choice(self.jumpArr, size=1 , p=ag.dist))
                        self.getNeighbours(x,ag.jump)
                        self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                        if len(self.neighbours)&gt;1:
                            ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                            # print(f&#34;step {step} agent {ag.name} chose random move &#34;)
                        elif ag.jump&gt;2:
                            print(f&#34;Using all positions within the jump radius {ag.jump}&#34;)
                            self.getNeighbours(x,ag.jump, any=1)
                            self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                            if len(self.neighbours)&gt;1:
                                ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                            else:
                                print(f&#34;agent {ag.name} can&#39;t move&#34;)
                        else:
                            None
                elif len([m for m in self.receptorPos if sum((m-x)**2) &lt;= ag.bindSth**2])&gt;0: # for an unbound ligand, check if a receptor is nearby
                    ag.isBound=1
                    ag.bdTime= int(100*ag.resTime*np.log(1/np.random.uniform(0.001,0.999,1))) # exponential distribution for binding times
                    ag.bState.append(1)
                    ag.jump= int(np.random.choice(self.jumpArr, size=1 , p=self.boundDist))
                    self.getNeighbours(x,ag.jump)
                    self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                    # ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                    if len(self.neighbours)&gt;1:
                        ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                        # print(f&#34;step {step} agent {ag.name} chose random move &#34;)
                    elif ag.jump&gt;2:
                        print(f&#34;Using all positions within the jump radius {ag.jump}&#34;)
                        self.getNeighbours(x,ag.jump, any=1)
                        self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                        if len(self.neighbours)&gt;1:
                            ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                        else:
                            print(f&#34;agent {ag.name} can&#39;t move&#34;)
                    else:
                        None
                    ag.bdCount+=1
                else:
                    ag.bState.append(0)
                    ag.jump= int(np.random.choice(self.jumpArr, size=1 , p=ag.dist))
                    self.getNeighbours(x,ag.jump)
                    self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                    if len(self.neighbours)&gt;1:
                        ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                        # print(f&#34;step {step} agent {ag.name} chose random move &#34;)
                    elif ag.jump&gt;2:
                        print(f&#34;Using all positions within the jump radius {ag.jump}&#34;)
                        self.getNeighbours(x,ag.jump, any=1)
                        self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                        if len(self.neighbours)&gt;1:
                            ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                        else:
                            print(f&#34;agent {ag.name} can&#39;t move&#34;)
                    else:
                        None
            ag.track[step+1]=ag.pos

    def observe(self,step,fig,cmap):
        &#34;&#34;&#34;Generates plots of agent tracks

        Args:
            `self`\n
            `step`- simulation step number \n
            `fig` - plt.figure (blank figure to draw the plot)\n
            `cmap` - colormap to color different agents \n

        Generates:
            a plot of tracks at self.dir \n
        &#34;&#34;&#34;
        plt.title(f&#34;time_{step*10}_ms&#34;)
        plt.xlim(0,self.gS[0])
        plt.ylim(0,self.gS[1])
        for ag, col in zip(self.agents, cmap):
            x = ag.track[:step+2,0][-2:]
            y = ag.track[:step+2,1][-2:]
            if &#34;oep&#34; in ag.name:
                plt.plot(x[-1], y[-1], &#39;ks&#39;, markersize=0.5)
            else:
                plt.plot(x,y, &#39;-&#39;, label=ag.name, linewidth=2, color = col, zorder=2)
                # x,y=ag.track[-2]
                # x1,y1=ag.track[-1]
                # dx,dy=[x1-x,y1-y]
                # plt.arrow(x,y,dx/2,dy/2,lw=0, color=&#39;k&#39;, head_width=40., zorder=20)
                dx,dy=[x[1]-x[0],y[1]-y[0]]
                plt.arrow(x[0],y[0],dx/2,dy/2, lw=0., fc=&#34;k&#34;, ec=&#34;k&#34;, head_width=10, head_length=10, zorder=20)
        # plt.legend(loc=&#39;lower left&#39;)
        fig.canvas.draw_idle()
        fname=self.dir/f&#34;traceAt_{step}.tif&#34;
        plt.savefig(fname)
        fig.canvas.flush_events()
        plt.clf()

    def plotBoundFrac(self, step, fig):
        &#34;&#34;&#34;To plot the bound fraction.&#34;&#34;&#34;
        plt.title(f&#34;Time {step*0.01:.3f} s&#34;)
        plt.ylim(0,1)
        nodFrac=[ag.isBound for ag in self.agents if &#34;nod&#34; in ag.name]
        lefFrac=[ag.isBound for ag in self.agents if &#34;lef&#34; in ag.name]
        x= [&#34;nodal&#34;, &#34;lefty&#34;]
        y=[sum(nodFrac)/len(nodFrac), sum(lefFrac)/len(lefFrac)]
        plt.ylabel(&#34;Bound Fraction&#34;)
        plt.bar(x,y, width=0.2)
        fig.canvas.draw_idle()
        fname=self.dir/f&#34;BoundFrac_{step}.tif&#34;
        plt.savefig(fname)
        fig.canvas.flush_events()
        plt.clf()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="morphogenDiffusionABM.simulateABM.customPDF"><code class="name flex">
<span>def <span class="ident">customPDF</span></span>(<span>self, r, D=10, tau=0.01)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates distribution of probabilities for given jump distances</p>
<h2 id="args">Args</h2>
<p><code>self</code> </p>
<p><code>r</code> - array of jump distance (numpy.array) </p>
<p><code>D</code> - diffusion coefficient (in um^2/s) </p>
<p><code>tau</code> - duration of the simulation step (in s). default = 0.01 (10 ms) </p>
<h2 id="returns">Returns</h2>
<p>Array of probabilities of jump distances</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def customPDF(self,r, D=10, tau=0.01):
    &#34;&#34;&#34;Generates distribution of probabilities for given jump distances

    Args:
        `self` \n
        `r` - array of jump distance (numpy.array) \n
        `D` - diffusion coefficient (in um^2/s) \n
        `tau` - duration of the simulation step (in s). default = 0.01 (10 ms) \n

    Returns:
        Array of probabilities of jump distances \n
    &#34;&#34;&#34;
    # D = 10 mu^2/s, tau = 0.01 s
    # r is jump distance in pixels
    D = D*10**4 # conversion of um^2 to px^2/s
    p= (r/(2*D*tau)) * np.exp(-r**2/(4*D*tau))
    p = p/np.sum(p)
    return p</code></pre>
</details>
</dd>
<dt id="morphogenDiffusionABM.simulateABM.drawCircle"><code class="name flex">
<span>def <span class="ident">drawCircle</span></span>(<span>self, pos, r)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns radial positions at a given distance from the given position</p>
<h2 id="args">Args</h2>
<p><code>self</code> </p>
<p><code>pos</code>- [x,y] for given position </p>
<p><code>r</code> - radius of the circle </p>
<h2 id="returns">Returns</h2>
<p>A list of positions on the circle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawCircle(self,pos,r):
    &#34;&#34;&#34;Returns radial positions at a given distance from the given position

    Args:
        `self` \n
        `pos`- [x,y] for given position \n
        `r` - radius of the circle \n

    Returns:
        A list of positions on the circle. \n
    &#34;&#34;&#34;
    r= r+1
    vPosList=[]
    nodes=16*r
    p0,p1=pos
    for i in range(int(nodes)):
        i=float(i)
        a =p0+r*np.cos(2.*(i+1)*np.pi/nodes)
        b =p1+r*np.sin(2.*(i+1)*np.pi/nodes)
        a= int(round(a))
        b= int(round(b))
        vPosList.append([a,b])
    return vPosList</code></pre>
</details>
</dd>
<dt id="morphogenDiffusionABM.simulateABM.getMemPos"><code class="name flex">
<span>def <span class="ident">getMemPos</span></span>(<span>self, dir=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Detects edges (membrane positions) in the grid.</p>
<h2 id="args">Args</h2>
<p><code>self</code> </p>
<p><code>dir</code> - default = None, provide a directory path to save a .tif image of the membrane positions </p>
<h2 id="modifies">Modifies</h2>
<p>Attribute:
<code>membranePos</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMemPos(self, dir=None):
    &#34;&#34;&#34;Detects edges (membrane positions) in the grid.

    Args:
        `self` \n
        `dir` - default = None, provide a directory path to save a .tif image of the membrane positions \n

    Modifies:
        Attribute:
            `membranePos` \n
    &#34;&#34;&#34;
    imGradx,imGrady = np.gradient(self.grid)
    imGrad = np.absolute(imGradx)+np.absolute(imGrady)
    self.membranePos=np.argwhere(imGrad)
    if dir is not None:
        self.membranePos_sort=self.membranePos[np.argsort(self.membranePos[:,1])]
        self.memSet = set([tuple(x) for x in self.membranePos_sort])
        showMem = np.zeros((self.gS[0], self.gS[1]))
        for [x,y] in self.membranePos_sort: showMem[x,y] = 100
        plt.figure()
        plt.imshow(showMem.T, origin= &#34;lower&#34;)
        plt.savefig(self.dir/&#34;membrane.tif&#34;)
    print(f&#34;len of membranePos is {len(self.membranePos)}&#34;)</code></pre>
</details>
</dd>
<dt id="morphogenDiffusionABM.simulateABM.getNeighbours"><code class="name flex">
<span>def <span class="ident">getNeighbours</span></span>(<span>self, pos, r, any=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the self.neighbours with neighbours of given position.</p>
<h2 id="args">Args</h2>
<p><code>self</code> </p>
<p><code>pos</code> - given position [x,y] </p>
<p><code>r</code> - distance from pos </p>
<p><code>any</code> - boolean </p>
<pre><code>0- only take positions at distance r
1- take all positions within radius r
</code></pre>
<h2 id="modifies">Modifies</h2>
<p>Attributes:
<code>neighbours</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getNeighbours(self, pos, r, any=0):
    &#34;&#34;&#34;Updates the self.neighbours with neighbours of given position.

    Args:
        `self` \n
        `pos` - given position [x,y] \n
        `r` - distance from pos \n
        `any` - boolean \n
            0- only take positions at distance r
            1- take all positions within radius r

    Modifies:
        Attributes:
            `neighbours` \n
    &#34;&#34;&#34;
    self.neighbours = np.zeros(8*r)
    if any:
        vPos = []
        for r1 in range(2, r):
            vPos.append(self.drawCircle(pos,r1))
        vPosList= [b for a in vPos for b in a]
    else:
        vPosList=self.drawCircle(pos,r)
    # vPosList = [[a[0]%self.gS[0],a[1]%self.gS[1]] for a in vPosList] # for per boundary
    self.neighbours = np.array([a for a in vPosList if 0&lt;a[0]&lt;gS[0] and 0&lt;a[1]&lt;gS[1]])</code></pre>
</details>
</dd>
<dt id="morphogenDiffusionABM.simulateABM.grid2D"><code class="name flex">
<span>def <span class="ident">grid2D</span></span>(<span>self, gsize, gridImg=None, nrw=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes the 2D grid for simulation</p>
<h2 id="args">Args</h2>
<p><code>self</code> </p>
<p><code>gsize</code>- size of the grid </p>
<p><code>gridImg</code> - input custom grid array (a numpy.array object) </p>
<p><code>nrw</code> - Narrowness (An integer to make the grid narrower or wider. </p>
<pre><code>nrw=0 means no change in initial grid

nrw&gt;0 means make the grid narrower, nrw&lt;0 means make the grid wider

1 nrw unit chages the width of extracellular space by 2 pixels or 20 nm.)
</code></pre>
<h2 id="modifies">Modifies</h2>
<p>Class <code><a title="morphogenDiffusionABM.simulateABM" href="#morphogenDiffusionABM.simulateABM">simulateABM</a></code> </p>
<p>Attributes:
<code>grid</code>, <code>membranePos</code>, <code>allowedPos</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grid2D(self, gsize, gridImg=None, nrw=0):
    &#34;&#34;&#34;Makes the 2D grid for simulation

    Args:
        `self` \n
        `gsize`- size of the grid \n
        `gridImg` - input custom grid array (a numpy.array object) \n
        `nrw` - Narrowness (An integer to make the grid narrower or wider. \n
            nrw=0 means no change in initial grid \n
            nrw&gt;0 means make the grid narrower, nrw&lt;0 means make the grid wider \n
            1 nrw unit chages the width of extracellular space by 2 pixels or 20 nm.) \n

    Modifies:
        Class `simulateABM` \n
        Attributes:
            `grid`, `membranePos`, `allowedPos` \n
    &#34;&#34;&#34;
    if gridImg is not None:
        self.grid= gridImg
        self.gS = gsize
    else:
        grid=np.zeros((gsize[0],gsize[1]))
        x1,x2=(int(0.45*gsize[0]), int(0.55*gsize[0]))
        y1,y2=(int(0.6*gsize[1]), int(0.8*gsize[1]))
        for x in range(x1,x2):
            grid[x,:]=1
        for y in range(y1, y2):
            addCent = (y/gsize[1] - 0.6)
            x1,x2= (int((0.45-addCent)*gsize[0]), int((0.55+addCent)*gsize[0]))
            grid[x1:x2, y] = 1
        for y in range(y2, int(0.9*gsize[1])):
            grid[:,y]=1
        self.grid = grid

    nrwGrid = 1
    if nrw&lt;0:
        nrw= -nrw
        nrwGrid= 0

    for n in range(nrw):
        self.getMemPos()
        for a in self.membranePos:
            self.grid[a[0],a[1]] = 0 if nrwGrid else 1
            self.getNeighbours(a,1)
            for b in self.neighbours:
                self.grid[b[0],b[1]] = 0 if nrwGrid else 1

    self.allowedPos = np.argwhere(self.grid)
    maxX = np.max(self.allowedPos[:,0])
    self.oneSidePos=np.array([a for a in self.allowedPos if a[0]==maxX])
    print(f&#34;len of allowedPos is {len(self.allowedPos)}&#34;)

    #save grid as .csv and .tiff files
    plt.figure()
    plt.imshow(self.grid.T, origin= &#34;lower&#34;)
    plt.savefig(self.dir/&#34;grid.tif&#34;)
    plt.close()
    np.savetxt(self.dir/&#34;grid.csv&#34;, self.grid, delimiter= &#34;,&#34;, fmt=&#39;%s&#39;)</code></pre>
</details>
</dd>
<dt id="morphogenDiffusionABM.simulateABM.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self, num=1, name='sailor', diffCoef=10, bindSth=0, oneSide=0, resTime=0, eqFrac=0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes the agents for the simulation</p>
<h2 id="args">Args</h2>
<p><code>num</code> - number of agents </p>
<p><code>name</code> - name of agent </p>
<p><code>diffCoef</code> - diffusion coefficient </p>
<p><code>bindSth</code> - bindSth (integer - 0, 1, &hellip;). A receptor with the radius of bindSth is detected for binding. </p>
<p><code>oneSide</code> - boolean (default = 0), </p>
<pre><code>0 to initiate agents at random positions,

1 to initiate agents on one side of the grid
</code></pre>
<p><code>resTime</code> - average residence time for the agent </p>
<p><code>eqFrac</code> - initial bound fraction (0 means all agents are free, 1 means all agents are bound, default = 0.5) </p>
<h2 id="modifies">Modifies</h2>
<p>Class <code><a title="morphogenDiffusionABM.agent" href="#morphogenDiffusionABM.agent">agent</a></code> </p>
<p>Attributes:
<code>name</code>, <code>id</code>, <code>track</code>, <code>bState</code>, <code>pos</code>, <code>resTime</code>, <code>bdTime</code>, <code>bdCount</code>, <code>isBound</code>, <code>diffCoef</code>, <code>dist</code>, <code>jump</code>, &hellip; </p>
<p>Class <code><a title="morphogenDiffusionABM.simulateABM" href="#morphogenDiffusionABM.simulateABM">simulateABM</a></code> </p>
<p>Attributes:
<code>receptorPos</code>, <code>agents</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(self, num=1, name=&#34;sailor&#34;, diffCoef=10, bindSth=0, oneSide=0, resTime=0, eqFrac=0.5 ):
    &#34;&#34;&#34;Initializes the agents for the simulation

    Args:
        `num` - number of agents \n
        `name` - name of agent \n
        `diffCoef` - diffusion coefficient \n
        `bindSth` - bindSth (integer - 0, 1, ...). A receptor with the radius of bindSth is detected for binding. \n
        `oneSide` - boolean (default = 0), \n
            0 to initiate agents at random positions, \n
            1 to initiate agents on one side of the grid \n
        `resTime` - average residence time for the agent \n
        `eqFrac` - initial bound fraction (0 means all agents are free, 1 means all agents are bound, default = 0.5) \n

    Modifies:
        Class `agent` \n
        Attributes:
            `name`, `id`, `track`, `bState`, `pos`, `resTime`, `bdTime`, `bdCount`, `isBound`, `diffCoef`, `dist`, `jump`, ... \n
        Class `simulateABM` \n
        Attributes:
            `receptorPos`, `agents` \n
    &#34;&#34;&#34;
    # define the allowed receptor positions along the membrane
    # The idea is at the membrane within one step one can find a zero as well as nonzero position
    self.receptorPos=[]
    for i in range(num):
        ag=agent(i)
        ag.track=np.zeros((self.steps+1, 2))
        # ag.id=i
        ag.name= f&#34;{name}_{i:04d}&#34;
        ag.bState= []
        if &#34;oep&#34; in ag.name:
            # ag.pos= self.membranePos[randint(0,len(self.membranePos)-1)] # to randomly pick initial position
            ag.pos= self.membranePos_sort[i*self.recepDens] # uniform receptor positions
            self.receptorPos.append(ag.pos)
        else:
            ag.resTime=resTime
            ag.bdTime= int(100*ag.resTime*np.log(1/np.random.uniform(0.001,0.999,1))) # exponential distribution for binding times
            ag.bdCount=0
            ag.isBound=np.random.choice([0,1], p=[1-eqFrac, eqFrac])
            ag.diffCoef=diffCoef
            ag.dist = self.customPDF(self.jumpArr, ag.diffCoef)
            ag.jump= int(np.random.choice(self.jumpArr, size=1 , p=ag.dist))
            if oneSide==1:
                ag.pos= self.oneSidePos[randint(0,len(self.oneSidePos)-1)]
            else:
                ag.pos= self.allowedPos[randint(0,len(self.allowedPos)-1)]
        ag.track[0]=ag.pos
        ag.bindSth=bindSth
        self.agents.append(ag)
    self.receptorPos=np.asarray(self.receptorPos)</code></pre>
</details>
</dd>
<dt id="morphogenDiffusionABM.simulateABM.observe"><code class="name flex">
<span>def <span class="ident">observe</span></span>(<span>self, step, fig, cmap)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates plots of agent tracks</p>
<h2 id="args">Args</h2>
<p><code>self</code></p>
<p><code>step</code>- simulation step number </p>
<p><code>fig</code> - plt.figure (blank figure to draw the plot)</p>
<p><code>cmap</code> - colormap to color different agents </p>
<h2 id="generates">Generates</h2>
<p>a plot of tracks at self.dir</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def observe(self,step,fig,cmap):
    &#34;&#34;&#34;Generates plots of agent tracks

    Args:
        `self`\n
        `step`- simulation step number \n
        `fig` - plt.figure (blank figure to draw the plot)\n
        `cmap` - colormap to color different agents \n

    Generates:
        a plot of tracks at self.dir \n
    &#34;&#34;&#34;
    plt.title(f&#34;time_{step*10}_ms&#34;)
    plt.xlim(0,self.gS[0])
    plt.ylim(0,self.gS[1])
    for ag, col in zip(self.agents, cmap):
        x = ag.track[:step+2,0][-2:]
        y = ag.track[:step+2,1][-2:]
        if &#34;oep&#34; in ag.name:
            plt.plot(x[-1], y[-1], &#39;ks&#39;, markersize=0.5)
        else:
            plt.plot(x,y, &#39;-&#39;, label=ag.name, linewidth=2, color = col, zorder=2)
            # x,y=ag.track[-2]
            # x1,y1=ag.track[-1]
            # dx,dy=[x1-x,y1-y]
            # plt.arrow(x,y,dx/2,dy/2,lw=0, color=&#39;k&#39;, head_width=40., zorder=20)
            dx,dy=[x[1]-x[0],y[1]-y[0]]
            plt.arrow(x[0],y[0],dx/2,dy/2, lw=0., fc=&#34;k&#34;, ec=&#34;k&#34;, head_width=10, head_length=10, zorder=20)
    # plt.legend(loc=&#39;lower left&#39;)
    fig.canvas.draw_idle()
    fname=self.dir/f&#34;traceAt_{step}.tif&#34;
    plt.savefig(fname)
    fig.canvas.flush_events()
    plt.clf()</code></pre>
</details>
</dd>
<dt id="morphogenDiffusionABM.simulateABM.plotBoundFrac"><code class="name flex">
<span>def <span class="ident">plotBoundFrac</span></span>(<span>self, step, fig)</span>
</code></dt>
<dd>
<div class="desc"><p>To plot the bound fraction.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotBoundFrac(self, step, fig):
    &#34;&#34;&#34;To plot the bound fraction.&#34;&#34;&#34;
    plt.title(f&#34;Time {step*0.01:.3f} s&#34;)
    plt.ylim(0,1)
    nodFrac=[ag.isBound for ag in self.agents if &#34;nod&#34; in ag.name]
    lefFrac=[ag.isBound for ag in self.agents if &#34;lef&#34; in ag.name]
    x= [&#34;nodal&#34;, &#34;lefty&#34;]
    y=[sum(nodFrac)/len(nodFrac), sum(lefFrac)/len(lefFrac)]
    plt.ylabel(&#34;Bound Fraction&#34;)
    plt.bar(x,y, width=0.2)
    fig.canvas.draw_idle()
    fname=self.dir/f&#34;BoundFrac_{step}.tif&#34;
    plt.savefig(fname)
    fig.canvas.flush_events()
    plt.clf()</code></pre>
</details>
</dd>
<dt id="morphogenDiffusionABM.simulateABM.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, step)</span>
</code></dt>
<dd>
<div class="desc"><p>To update the agents at each simulation step</p>
<h2 id="args">Args</h2>
<p><code>self</code> </p>
<p><code>step</code> - simulation step number (int) </p>
<h2 id="modifies">Modifies</h2>
<p>Class <code><a title="morphogenDiffusionABM.agent" href="#morphogenDiffusionABM.agent">agent</a></code> </p>
<p>Attributes:
<code>bState</code>, <code>pos</code>, <code>isBound</code>, <code>bdCount</code>, <code>jump</code> </p>
<p>Class <code><a title="morphogenDiffusionABM.simulateABM" href="#morphogenDiffusionABM.simulateABM">simulateABM</a></code> </p>
<p>Attributes:
<code>agents</code>, <code>neighbours</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self,step):
    &#34;&#34;&#34;To update the agents at each simulation step

    Args:
        `self` \n
        `step` - simulation step number (int) \n

    Modifies:
        Class `agent` \n
        Attributes:
            `bState`, `pos`, `isBound`, `bdCount`, `jump` \n
        Class `simulateABM` \n
        Attributes:
            `agents`, `neighbours` \n
    &#34;&#34;&#34;
    for ag in self.agents:
        x = ag.pos
        # moveTo = []
        if &#34;oep&#34; in ag.name: # update for the receptor
            ag.bState.append(0) # this is not really meaningful,
        else: # this is for the ligands
            # proximity = [m for m in self.receptorPos if sum((m-x)**2) &lt;= 2*(ag.bindSth)**2]
            if ag.isBound: # bound ligand stays bound if counter on resTime hasn&#39;t run out
                if ag.bdCount&lt;=ag.bdTime:
                    ag.bState.append(1)
                    ag.jump= int(np.random.choice(self.jumpArr, size=1 , p=self.boundDist))
                    self.getNeighbours(x,ag.jump)
                    self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                    # ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                    if len(self.neighbours)&gt;1:
                        ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                        # print(f&#34;step {step} agent {ag.name} chose random move &#34;)
                    elif ag.jump&gt;2:
                        print(f&#34;Using all positions within the jump radius {ag.jump}&#34;)
                        self.getNeighbours(x,ag.jump, any=1)
                        self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                        if len(self.neighbours)&gt;1:
                            ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                        else:
                            print(f&#34;agent {ag.name} can&#39;t move&#34;)
                    else:
                        None
                    ag.bdCount+=1
                else: # when the counter is exceeded ligand becomes unbound
                    ag.isBound=0
                    ag.bState.append(0)
                    ag.bdCount=0
                    ag.jump= int(np.random.choice(self.jumpArr, size=1 , p=ag.dist))
                    self.getNeighbours(x,ag.jump)
                    self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                    if len(self.neighbours)&gt;1:
                        ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                        # print(f&#34;step {step} agent {ag.name} chose random move &#34;)
                    elif ag.jump&gt;2:
                        print(f&#34;Using all positions within the jump radius {ag.jump}&#34;)
                        self.getNeighbours(x,ag.jump, any=1)
                        self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                        if len(self.neighbours)&gt;1:
                            ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                        else:
                            print(f&#34;agent {ag.name} can&#39;t move&#34;)
                    else:
                        None
            elif len([m for m in self.receptorPos if sum((m-x)**2) &lt;= ag.bindSth**2])&gt;0: # for an unbound ligand, check if a receptor is nearby
                ag.isBound=1
                ag.bdTime= int(100*ag.resTime*np.log(1/np.random.uniform(0.001,0.999,1))) # exponential distribution for binding times
                ag.bState.append(1)
                ag.jump= int(np.random.choice(self.jumpArr, size=1 , p=self.boundDist))
                self.getNeighbours(x,ag.jump)
                self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                # ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                if len(self.neighbours)&gt;1:
                    ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                    # print(f&#34;step {step} agent {ag.name} chose random move &#34;)
                elif ag.jump&gt;2:
                    print(f&#34;Using all positions within the jump radius {ag.jump}&#34;)
                    self.getNeighbours(x,ag.jump, any=1)
                    self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                    if len(self.neighbours)&gt;1:
                        ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                    else:
                        print(f&#34;agent {ag.name} can&#39;t move&#34;)
                else:
                    None
                ag.bdCount+=1
            else:
                ag.bState.append(0)
                ag.jump= int(np.random.choice(self.jumpArr, size=1 , p=ag.dist))
                self.getNeighbours(x,ag.jump)
                self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                if len(self.neighbours)&gt;1:
                    ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                    # print(f&#34;step {step} agent {ag.name} chose random move &#34;)
                elif ag.jump&gt;2:
                    print(f&#34;Using all positions within the jump radius {ag.jump}&#34;)
                    self.getNeighbours(x,ag.jump, any=1)
                    self.neighbours=np.array([a for a in self.neighbours if self.grid[a[0],a[1]]&gt;0])
                    if len(self.neighbours)&gt;1:
                        ag.pos= self.neighbours[randint(0,len(self.neighbours)-1)]
                    else:
                        print(f&#34;agent {ag.name} can&#39;t move&#34;)
                else:
                    None
        ag.track[step+1]=ag.pos</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="morphogenDiffusionABM.agent" href="#morphogenDiffusionABM.agent">agent</a></code></h4>
</li>
<li>
<h4><code><a title="morphogenDiffusionABM.simulateABM" href="#morphogenDiffusionABM.simulateABM">simulateABM</a></code></h4>
<ul class="two-column">
<li><code><a title="morphogenDiffusionABM.simulateABM.customPDF" href="#morphogenDiffusionABM.simulateABM.customPDF">customPDF</a></code></li>
<li><code><a title="morphogenDiffusionABM.simulateABM.drawCircle" href="#morphogenDiffusionABM.simulateABM.drawCircle">drawCircle</a></code></li>
<li><code><a title="morphogenDiffusionABM.simulateABM.getMemPos" href="#morphogenDiffusionABM.simulateABM.getMemPos">getMemPos</a></code></li>
<li><code><a title="morphogenDiffusionABM.simulateABM.getNeighbours" href="#morphogenDiffusionABM.simulateABM.getNeighbours">getNeighbours</a></code></li>
<li><code><a title="morphogenDiffusionABM.simulateABM.grid2D" href="#morphogenDiffusionABM.simulateABM.grid2D">grid2D</a></code></li>
<li><code><a title="morphogenDiffusionABM.simulateABM.initialize" href="#morphogenDiffusionABM.simulateABM.initialize">initialize</a></code></li>
<li><code><a title="morphogenDiffusionABM.simulateABM.observe" href="#morphogenDiffusionABM.simulateABM.observe">observe</a></code></li>
<li><code><a title="morphogenDiffusionABM.simulateABM.plotBoundFrac" href="#morphogenDiffusionABM.simulateABM.plotBoundFrac">plotBoundFrac</a></code></li>
<li><code><a title="morphogenDiffusionABM.simulateABM.update" href="#morphogenDiffusionABM.simulateABM.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>